# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: users.sql
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc import models


GET_USER_BY_EMAIL = """-- name: get_user_by_email \\:one
SELECT id, email, name, created_at, last_seen_at, total_sessions, total_bookings FROM users
WHERE email = :p1
"""


GET_USER_BY_ID = """-- name: get_user_by_id \\:one
SELECT id, email, name, created_at, last_seen_at, total_sessions, total_bookings FROM users
WHERE id = :p1
"""


INCREMENT_USER_BOOKING_COUNT = """-- name: increment_user_booking_count \\:exec
UPDATE users
SET total_bookings = total_bookings + 1
WHERE id = :p1
"""


INCREMENT_USER_SESSION_COUNT = """-- name: increment_user_session_count \\:exec
UPDATE users
SET total_sessions = total_sessions + 1,
    last_seen_at = now()
WHERE id = :p1
"""


UPSERT_USER_BY_EMAIL = """-- name: upsert_user_by_email \\:one
INSERT INTO users (id, email, name, created_at, last_seen_at, total_sessions, total_bookings)
VALUES (:p1, :p2, :p3, now(), now(), 0, 0)
ON CONFLICT (email)
DO UPDATE SET
  name = COALESCE(EXCLUDED.name, users.name),
  last_seen_at = now()
RETURNING id, email, name, created_at, last_seen_at, total_sessions, total_bookings
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_user_by_email(self, *, email: Optional[str]) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_BY_EMAIL), {"p1": email}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )

    def get_user_by_id(self, *, id: str) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )

    def increment_user_booking_count(self, *, id: str) -> None:
        self._conn.execute(sqlalchemy.text(INCREMENT_USER_BOOKING_COUNT), {"p1": id})

    def increment_user_session_count(self, *, id: str) -> None:
        self._conn.execute(sqlalchemy.text(INCREMENT_USER_SESSION_COUNT), {"p1": id})

    def upsert_user_by_email(self, *, id: str, email: Optional[str], name: Optional[str]) -> Optional[models.User]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_USER_BY_EMAIL), {"p1": id, "p2": email, "p3": name}).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_user_by_email(self, *, email: Optional[str]) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_BY_EMAIL), {"p1": email})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )

    async def get_user_by_id(self, *, id: str) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )

    async def increment_user_booking_count(self, *, id: str) -> None:
        await self._conn.execute(sqlalchemy.text(INCREMENT_USER_BOOKING_COUNT), {"p1": id})

    async def increment_user_session_count(self, *, id: str) -> None:
        await self._conn.execute(sqlalchemy.text(INCREMENT_USER_SESSION_COUNT), {"p1": id})

    async def upsert_user_by_email(self, *, id: str, email: Optional[str], name: Optional[str]) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_USER_BY_EMAIL), {"p1": id, "p2": email, "p3": name})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            last_seen_at=row[4],
            total_sessions=row[5],
            total_bookings=row[6],
        )
