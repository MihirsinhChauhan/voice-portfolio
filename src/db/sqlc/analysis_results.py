# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: analysis_results.sql
import dataclasses
from typing import Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc import models


GET_ANALYSIS_RESULT_BY_SESSION_ID = """-- name: get_analysis_result_by_session_id \\:one
SELECT id, session_id, sentiment_score, engagement_score, lead_score, intent_label, summary, analysis_version, created_at FROM analysis_results
WHERE session_id = :p1
"""


INSERT_ANALYSIS_RESULT = """-- name: insert_analysis_result \\:one
INSERT INTO analysis_results (
    id, session_id, sentiment_score, engagement_score, lead_score,
    intent_label, summary, analysis_version
)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8)
RETURNING id, session_id, sentiment_score, engagement_score, lead_score, intent_label, summary, analysis_version, created_at
"""


@dataclasses.dataclass()
class InsertAnalysisResultParams:
    id: str
    session_id: str
    sentiment_score: float
    engagement_score: float
    lead_score: float
    intent_label: str
    summary: Optional[str]
    analysis_version: int


UPSERT_ANALYSIS_RESULT = """-- name: upsert_analysis_result \\:one
INSERT INTO analysis_results (
    id, session_id, sentiment_score, engagement_score, lead_score,
    intent_label, summary, analysis_version
)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8)
ON CONFLICT (session_id)
DO UPDATE SET
    sentiment_score = EXCLUDED.sentiment_score,
    engagement_score = EXCLUDED.engagement_score,
    lead_score = EXCLUDED.lead_score,
    intent_label = EXCLUDED.intent_label,
    summary = EXCLUDED.summary,
    analysis_version = EXCLUDED.analysis_version
RETURNING id, session_id, sentiment_score, engagement_score, lead_score, intent_label, summary, analysis_version, created_at
"""


@dataclasses.dataclass()
class UpsertAnalysisResultParams:
    id: str
    session_id: str
    sentiment_score: float
    engagement_score: float
    lead_score: float
    intent_label: str
    summary: Optional[str]
    analysis_version: int


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_analysis_result_by_session_id(self, *, session_id: str) -> Optional[models.AnalysisResult]:
        row = self._conn.execute(sqlalchemy.text(GET_ANALYSIS_RESULT_BY_SESSION_ID), {"p1": session_id}).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )

    def insert_analysis_result(self, arg: InsertAnalysisResultParams) -> Optional[models.AnalysisResult]:
        row = self._conn.execute(sqlalchemy.text(INSERT_ANALYSIS_RESULT), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.sentiment_score,
            "p4": arg.engagement_score,
            "p5": arg.lead_score,
            "p6": arg.intent_label,
            "p7": arg.summary,
            "p8": arg.analysis_version,
        }).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )

    def upsert_analysis_result(self, arg: UpsertAnalysisResultParams) -> Optional[models.AnalysisResult]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_ANALYSIS_RESULT), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.sentiment_score,
            "p4": arg.engagement_score,
            "p5": arg.lead_score,
            "p6": arg.intent_label,
            "p7": arg.summary,
            "p8": arg.analysis_version,
        }).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_analysis_result_by_session_id(self, *, session_id: str) -> Optional[models.AnalysisResult]:
        row = (await self._conn.execute(sqlalchemy.text(GET_ANALYSIS_RESULT_BY_SESSION_ID), {"p1": session_id})).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )

    async def insert_analysis_result(self, arg: InsertAnalysisResultParams) -> Optional[models.AnalysisResult]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_ANALYSIS_RESULT), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.sentiment_score,
            "p4": arg.engagement_score,
            "p5": arg.lead_score,
            "p6": arg.intent_label,
            "p7": arg.summary,
            "p8": arg.analysis_version,
        })).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )

    async def upsert_analysis_result(self, arg: UpsertAnalysisResultParams) -> Optional[models.AnalysisResult]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_ANALYSIS_RESULT), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.sentiment_score,
            "p4": arg.engagement_score,
            "p5": arg.lead_score,
            "p6": arg.intent_label,
            "p7": arg.summary,
            "p8": arg.analysis_version,
        })).first()
        if row is None:
            return None
        return models.AnalysisResult(
            id=row[0],
            session_id=row[1],
            sentiment_score=row[2],
            engagement_score=row[3],
            lead_score=row[4],
            intent_label=row[5],
            summary=row[6],
            analysis_version=row[7],
            created_at=row[8],
        )
