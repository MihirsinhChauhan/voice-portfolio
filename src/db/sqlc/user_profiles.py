# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: user_profiles.sql
import dataclasses
from typing import Any, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc import models


GET_USER_PROFILE_BY_USER_ID = """-- name: get_user_profile_by_user_id \\:one
SELECT user_id, company, domain, last_intent_type, booked_before, last_visit_at, created_at FROM user_profiles
WHERE user_id = :p1
"""


UPSERT_USER_PROFILE = """-- name: upsert_user_profile \\:one
INSERT INTO user_profiles (
    user_id, company, domain, last_intent_type, booked_before, last_visit_at, created_at
)
VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    COALESCE(:p5, false),
    now(),
    now()
)
ON CONFLICT (user_id)
DO UPDATE SET
  company = COALESCE(EXCLUDED.company, user_profiles.company),
  domain = COALESCE(EXCLUDED.domain, user_profiles.domain),
  last_intent_type = COALESCE(EXCLUDED.last_intent_type, user_profiles.last_intent_type),
  booked_before = COALESCE(EXCLUDED.booked_before, user_profiles.booked_before),
  last_visit_at = now()
RETURNING user_id, company, domain, last_intent_type, booked_before, last_visit_at, created_at
"""


@dataclasses.dataclass()
class UpsertUserProfileParams:
    user_id: str
    company: Optional[str]
    domain: Optional[str]
    last_intent_type: Optional[str]
    booked_before: Optional[Any]


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_user_profile_by_user_id(self, *, user_id: str) -> Optional[models.UserProfile]:
        row = self._conn.execute(sqlalchemy.text(GET_USER_PROFILE_BY_USER_ID), {"p1": user_id}).first()
        if row is None:
            return None
        return models.UserProfile(
            user_id=row[0],
            company=row[1],
            domain=row[2],
            last_intent_type=row[3],
            booked_before=row[4],
            last_visit_at=row[5],
            created_at=row[6],
        )

    def upsert_user_profile(self, arg: UpsertUserProfileParams) -> Optional[models.UserProfile]:
        row = self._conn.execute(sqlalchemy.text(UPSERT_USER_PROFILE), {
            "p1": arg.user_id,
            "p2": arg.company,
            "p3": arg.domain,
            "p4": arg.last_intent_type,
            "p5": arg.booked_before,
        }).first()
        if row is None:
            return None
        return models.UserProfile(
            user_id=row[0],
            company=row[1],
            domain=row[2],
            last_intent_type=row[3],
            booked_before=row[4],
            last_visit_at=row[5],
            created_at=row[6],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_user_profile_by_user_id(self, *, user_id: str) -> Optional[models.UserProfile]:
        row = (await self._conn.execute(sqlalchemy.text(GET_USER_PROFILE_BY_USER_ID), {"p1": user_id})).first()
        if row is None:
            return None
        return models.UserProfile(
            user_id=row[0],
            company=row[1],
            domain=row[2],
            last_intent_type=row[3],
            booked_before=row[4],
            last_visit_at=row[5],
            created_at=row[6],
        )

    async def upsert_user_profile(self, arg: UpsertUserProfileParams) -> Optional[models.UserProfile]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_USER_PROFILE), {
            "p1": arg.user_id,
            "p2": arg.company,
            "p3": arg.domain,
            "p4": arg.last_intent_type,
            "p5": arg.booked_before,
        })).first()
        if row is None:
            return None
        return models.UserProfile(
            user_id=row[0],
            company=row[1],
            domain=row[2],
            last_intent_type=row[3],
            booked_before=row[4],
            last_visit_at=row[5],
            created_at=row[6],
        )
