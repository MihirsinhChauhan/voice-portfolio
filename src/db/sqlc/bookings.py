# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: bookings.sql
import dataclasses
import datetime
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc import models


GET_BOOKINGS_BY_SESSION_ID = """-- name: get_bookings_by_session_id \\:many
SELECT id, session_id, user_id, scheduled_time, timezone, status, created_at FROM bookings
WHERE session_id = :p1
"""


GET_BOOKINGS_BY_USER_ID = """-- name: get_bookings_by_user_id \\:many
SELECT id, session_id, user_id, scheduled_time, timezone, status, created_at FROM bookings
WHERE user_id = :p1
ORDER BY scheduled_time DESC
"""


INSERT_BOOKING = """-- name: insert_booking \\:one
INSERT INTO bookings (id, session_id, user_id, scheduled_time, timezone, status)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6)
RETURNING id, session_id, user_id, scheduled_time, timezone, status, created_at
"""


@dataclasses.dataclass()
class InsertBookingParams:
    id: str
    session_id: str
    user_id: str
    scheduled_time: datetime.datetime
    timezone: Optional[str]
    status: str


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_bookings_by_session_id(self, *, session_id: str) -> Iterator[models.Booking]:
        result = self._conn.execute(sqlalchemy.text(GET_BOOKINGS_BY_SESSION_ID), {"p1": session_id})
        for row in result:
            yield models.Booking(
                id=row[0],
                session_id=row[1],
                user_id=row[2],
                scheduled_time=row[3],
                timezone=row[4],
                status=row[5],
                created_at=row[6],
            )

    def get_bookings_by_user_id(self, *, user_id: str) -> Iterator[models.Booking]:
        result = self._conn.execute(sqlalchemy.text(GET_BOOKINGS_BY_USER_ID), {"p1": user_id})
        for row in result:
            yield models.Booking(
                id=row[0],
                session_id=row[1],
                user_id=row[2],
                scheduled_time=row[3],
                timezone=row[4],
                status=row[5],
                created_at=row[6],
            )

    def insert_booking(self, arg: InsertBookingParams) -> Optional[models.Booking]:
        row = self._conn.execute(sqlalchemy.text(INSERT_BOOKING), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.user_id,
            "p4": arg.scheduled_time,
            "p5": arg.timezone,
            "p6": arg.status,
        }).first()
        if row is None:
            return None
        return models.Booking(
            id=row[0],
            session_id=row[1],
            user_id=row[2],
            scheduled_time=row[3],
            timezone=row[4],
            status=row[5],
            created_at=row[6],
        )


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_bookings_by_session_id(self, *, session_id: str) -> AsyncIterator[models.Booking]:
        result = await self._conn.stream(sqlalchemy.text(GET_BOOKINGS_BY_SESSION_ID), {"p1": session_id})
        async for row in result:
            yield models.Booking(
                id=row[0],
                session_id=row[1],
                user_id=row[2],
                scheduled_time=row[3],
                timezone=row[4],
                status=row[5],
                created_at=row[6],
            )

    async def get_bookings_by_user_id(self, *, user_id: str) -> AsyncIterator[models.Booking]:
        result = await self._conn.stream(sqlalchemy.text(GET_BOOKINGS_BY_USER_ID), {"p1": user_id})
        async for row in result:
            yield models.Booking(
                id=row[0],
                session_id=row[1],
                user_id=row[2],
                scheduled_time=row[3],
                timezone=row[4],
                status=row[5],
                created_at=row[6],
            )

    async def insert_booking(self, arg: InsertBookingParams) -> Optional[models.Booking]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_BOOKING), {
            "p1": arg.id,
            "p2": arg.session_id,
            "p3": arg.user_id,
            "p4": arg.scheduled_time,
            "p5": arg.timezone,
            "p6": arg.status,
        })).first()
        if row is None:
            return None
        return models.Booking(
            id=row[0],
            session_id=row[1],
            user_id=row[2],
            scheduled_time=row[3],
            timezone=row[4],
            status=row[5],
            created_at=row[6],
        )
