# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: sessions.sql
import dataclasses
import datetime
from typing import AsyncIterator, Iterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.db.sqlc import models


GET_PENDING_SESSIONS = """-- name: get_pending_sessions \\:many
SELECT id, user_id, started_at, ended_at, duration_sec, booking_made, analysis_status, analysis_version, r2_report_path, r2_audio_path, analysis_attempts, last_analysis_at, error_message, created_at FROM sessions
WHERE analysis_status = 'pending'
  AND analysis_attempts < :p1
ORDER BY created_at ASC
LIMIT :p2
"""


GET_SESSION_BY_ID = """-- name: get_session_by_id \\:one
SELECT id, user_id, started_at, ended_at, duration_sec, booking_made, analysis_status, analysis_version, r2_report_path, r2_audio_path, analysis_attempts, last_analysis_at, error_message, created_at FROM sessions
WHERE id = :p1
"""


INSERT_SESSION = """-- name: insert_session \\:one
INSERT INTO sessions (
    id, user_id, started_at, ended_at, duration_sec, booking_made,
    analysis_status, analysis_version, r2_report_path, r2_audio_path,
    analysis_attempts, last_analysis_at, error_message
)
VALUES (:p1, :p2, :p3, :p4, :p5, :p6, 'pending', :p7, :p8, :p9, 0, NULL, NULL)
RETURNING id, user_id, started_at, ended_at, duration_sec, booking_made, analysis_status, analysis_version, r2_report_path, r2_audio_path, analysis_attempts, last_analysis_at, error_message, created_at
"""


@dataclasses.dataclass()
class InsertSessionParams:
    id: str
    user_id: str
    started_at: datetime.datetime
    ended_at: Optional[datetime.datetime]
    duration_sec: Optional[int]
    booking_made: bool
    analysis_version: int
    r2_report_path: Optional[str]
    r2_audio_path: Optional[str]


MARK_SESSION_ANALYSIS_COMPLETED = """-- name: mark_session_analysis_completed \\:exec
UPDATE sessions
SET analysis_status = 'completed',
    error_message = NULL
WHERE id = :p1
"""


MARK_SESSION_ANALYSIS_FAILED = """-- name: mark_session_analysis_failed \\:exec
UPDATE sessions
SET analysis_status = 'failed',
    error_message = :p2
WHERE id = :p1
"""


MARK_SESSION_ANALYSIS_IN_PROGRESS = """-- name: mark_session_analysis_in_progress \\:exec
UPDATE sessions
SET analysis_status = 'in_progress',
    analysis_attempts = analysis_attempts + 1,
    last_analysis_at = now()
WHERE id = :p1
"""


UPDATE_SESSION_ANALYSIS_STATUS = """-- name: update_session_analysis_status \\:exec
UPDATE sessions
SET analysis_status = :p2,
    analysis_attempts = analysis_attempts + 1,
    last_analysis_at = now(),
    error_message = :p3
WHERE id = :p1
"""


class Querier:
    def __init__(self, conn: sqlalchemy.engine.Connection):
        self._conn = conn

    def get_pending_sessions(self, *, analysis_attempts: int, limit: int) -> Iterator[models.Session]:
        result = self._conn.execute(sqlalchemy.text(GET_PENDING_SESSIONS), {"p1": analysis_attempts, "p2": limit})
        for row in result:
            yield models.Session(
                id=row[0],
                user_id=row[1],
                started_at=row[2],
                ended_at=row[3],
                duration_sec=row[4],
                booking_made=row[5],
                analysis_status=row[6],
                analysis_version=row[7],
                r2_report_path=row[8],
                r2_audio_path=row[9],
                analysis_attempts=row[10],
                last_analysis_at=row[11],
                error_message=row[12],
                created_at=row[13],
            )

    def get_session_by_id(self, *, id: str) -> Optional[models.Session]:
        row = self._conn.execute(sqlalchemy.text(GET_SESSION_BY_ID), {"p1": id}).first()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            user_id=row[1],
            started_at=row[2],
            ended_at=row[3],
            duration_sec=row[4],
            booking_made=row[5],
            analysis_status=row[6],
            analysis_version=row[7],
            r2_report_path=row[8],
            r2_audio_path=row[9],
            analysis_attempts=row[10],
            last_analysis_at=row[11],
            error_message=row[12],
            created_at=row[13],
        )

    def insert_session(self, arg: InsertSessionParams) -> Optional[models.Session]:
        row = self._conn.execute(sqlalchemy.text(INSERT_SESSION), {
            "p1": arg.id,
            "p2": arg.user_id,
            "p3": arg.started_at,
            "p4": arg.ended_at,
            "p5": arg.duration_sec,
            "p6": arg.booking_made,
            "p7": arg.analysis_version,
            "p8": arg.r2_report_path,
            "p9": arg.r2_audio_path,
        }).first()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            user_id=row[1],
            started_at=row[2],
            ended_at=row[3],
            duration_sec=row[4],
            booking_made=row[5],
            analysis_status=row[6],
            analysis_version=row[7],
            r2_report_path=row[8],
            r2_audio_path=row[9],
            analysis_attempts=row[10],
            last_analysis_at=row[11],
            error_message=row[12],
            created_at=row[13],
        )

    def mark_session_analysis_completed(self, *, id: str) -> None:
        self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_COMPLETED), {"p1": id})

    def mark_session_analysis_failed(self, *, id: str, error_message: Optional[str]) -> None:
        self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_FAILED), {"p1": id, "p2": error_message})

    def mark_session_analysis_in_progress(self, *, id: str) -> None:
        self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_IN_PROGRESS), {"p1": id})

    def update_session_analysis_status(self, *, id: str, analysis_status: str, error_message: Optional[str]) -> None:
        self._conn.execute(sqlalchemy.text(UPDATE_SESSION_ANALYSIS_STATUS), {"p1": id, "p2": analysis_status, "p3": error_message})


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_pending_sessions(self, *, analysis_attempts: int, limit: int) -> AsyncIterator[models.Session]:
        result = await self._conn.stream(sqlalchemy.text(GET_PENDING_SESSIONS), {"p1": analysis_attempts, "p2": limit})
        async for row in result:
            yield models.Session(
                id=row[0],
                user_id=row[1],
                started_at=row[2],
                ended_at=row[3],
                duration_sec=row[4],
                booking_made=row[5],
                analysis_status=row[6],
                analysis_version=row[7],
                r2_report_path=row[8],
                r2_audio_path=row[9],
                analysis_attempts=row[10],
                last_analysis_at=row[11],
                error_message=row[12],
                created_at=row[13],
            )

    async def get_session_by_id(self, *, id: str) -> Optional[models.Session]:
        row = (await self._conn.execute(sqlalchemy.text(GET_SESSION_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            user_id=row[1],
            started_at=row[2],
            ended_at=row[3],
            duration_sec=row[4],
            booking_made=row[5],
            analysis_status=row[6],
            analysis_version=row[7],
            r2_report_path=row[8],
            r2_audio_path=row[9],
            analysis_attempts=row[10],
            last_analysis_at=row[11],
            error_message=row[12],
            created_at=row[13],
        )

    async def insert_session(self, arg: InsertSessionParams) -> Optional[models.Session]:
        row = (await self._conn.execute(sqlalchemy.text(INSERT_SESSION), {
            "p1": arg.id,
            "p2": arg.user_id,
            "p3": arg.started_at,
            "p4": arg.ended_at,
            "p5": arg.duration_sec,
            "p6": arg.booking_made,
            "p7": arg.analysis_version,
            "p8": arg.r2_report_path,
            "p9": arg.r2_audio_path,
        })).first()
        if row is None:
            return None
        return models.Session(
            id=row[0],
            user_id=row[1],
            started_at=row[2],
            ended_at=row[3],
            duration_sec=row[4],
            booking_made=row[5],
            analysis_status=row[6],
            analysis_version=row[7],
            r2_report_path=row[8],
            r2_audio_path=row[9],
            analysis_attempts=row[10],
            last_analysis_at=row[11],
            error_message=row[12],
            created_at=row[13],
        )

    async def mark_session_analysis_completed(self, *, id: str) -> None:
        await self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_COMPLETED), {"p1": id})

    async def mark_session_analysis_failed(self, *, id: str, error_message: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_FAILED), {"p1": id, "p2": error_message})

    async def mark_session_analysis_in_progress(self, *, id: str) -> None:
        await self._conn.execute(sqlalchemy.text(MARK_SESSION_ANALYSIS_IN_PROGRESS), {"p1": id})

    async def update_session_analysis_status(self, *, id: str, analysis_status: str, error_message: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(UPDATE_SESSION_ANALYSIS_STATUS), {"p1": id, "p2": analysis_status, "p3": error_message})
